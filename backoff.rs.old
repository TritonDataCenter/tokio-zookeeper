use backoff::{Error as BackoffError, ExponentialBackoff};
use futures::channel::mpsc::{self, UnboundedSender};
use futures::lock::Mutex as AsyncMutex;
use futures::sink::SinkExt;
use futures::stream::StreamExt;
use slog::{info, Logger};
use std::convert::From;
use std::net::SocketAddr;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use std::{cmp, i32, mem, u64};
use tokio::io::{self, ReadHalf, WriteHalf};
use tokio::net::TcpStream;
use tokio::time::{self, Elapsed};
use tokio_util::codec::{FramedRead, FramedWrite};

use crate::error::InternalError;
use crate::proto::decoder::ZkConnDecoder;
use crate::proto::encoder::{RequestWrapper, ZkEncoder};
use crate::proto::request::Request;
use crate::proto::response::Response;

//
// Encapsulates a backoff object and adds the notion of a time threshold that
// must be reached before the connection is considered stable and the backoff
// state is reset. This threshold is managed automatically using a background
// task -- users can just call ZkBackoff::next_backoff() normally.
//
pub(crate) struct ZkBackoff {
    backoff: Arc<AsyncMutex<ExponentialBackoff>>,
    //
    // Internal channel used for indicating that an error has occurred to the
    // stability-tracking thread
    //
    error_tx: UnbountedSender<ZkBackoffMsg>,
    log: Logger,
}

//
// For use by ZkBackoff object.
//
enum ZkBackoffMsg {
    //
    // The Duration is the duration of the backoff in response to the error.
    //
    ErrorOccurred(Duration),
}

//
// For use by ZkBackoff object.
//
enum ZkBackoffState {
    Stable,
    //
    // The Duration is the duration of the backoff in response to the error.
    //
    Unstable(Duration),
}

impl ZkBackoff {
    fn new(max_elapsed_time: Duration, log: Logger) -> Self {
        let mut backoff = ExponentialBackoff::default();
        backoff.max_elapsed_time = Some(max_elapsed_time);
        let (error_tx, error_rx) = mpsc::unbounded();

        let (error_tx, error_rx) = channel();
        let backoff = Arc::new(AsyncMutex::new(backoff));

        //
        // Start the stability-tracking task.
        //
        //
        // The waiting period for stability starts from the _time of successful
        // connection_. The time of successful connection, if it occurs at all,
        // will always be equal to (time of last error + duration of resulting
        // backoff). Thus, from time of last error, we must wait (duration of
        // resulting backoff + stability threshold) in order for the connection
        // to be considered stable. Thus, we pass the backoff duration from
        // next_backoff to this thread so the thread can figure out how long to
        // wait for stability.
        //
        // Note that this thread doesn't actually _know_ if the connect
        // operation succeeds, because we only touch the ZkBackoff
        // object when an error occurs. However, we can assume that it succeeds
        // when waiting for stability, because, if the connect operation fails,
        // this thread will receive another error and restart the wait period.
        //
        // If the connect operation takes longer than BACKOFF_RESET_THRESHOLD to
        // complete and then fails, we'll reset the backoff erroneously. This
        // situation is highly unlikely, so we'll cross that bridge when we come
        // to it.
        //
        let backoff_clone = Arc::clone(&backoff);
        let task_log = log.clone();
        debug!(log, "spawning stability-tracking task");
        tokio::task::spawn(async move {
            let mut state = ZkBackoffState::Stable;
            loop {
                match state {
                    ZkBackoffState::Stable => {
                        //
                        // Wait for an error to happen
                        //
                        debug!(task_log, "backoff stable; waiting for error");
                        match error_rx.next().await {
                            //
                            // * zero days since last accident *
                            //
                            Ok(ZkBackoffMsg::ErrorOccurred(new_backoff)) => {
                                info!(
                                    task_log,
                                    "error received; backoff transitioning to \
                                     unstable state"
                                );
                                state = ZkBackoffState::Unstable(new_backoff);
                                continue;
                            }
                            //
                            // ZkBackoff object was dropped, so we exit
                            // the thread
                            //
                            Err(_) => break,
                        }
                    }
                    ZkBackoffState::Unstable(current_backoff) => {
                        debug!(task_log, "backoff unstable; waiting for stability");
                        //
                        // See large comment above for explanation of why we
                        // wait this long
                        //
                        match time::timeout(
                            current_backoff + *BACKOFF_RESET_THRESHOLD,
                            error_rx.next(),
                        )
                        .await
                        {
                            //
                            // We got another error, so restart the countdown
                            //
                            Ok(ZkBackoffMsg::ErrorOccurred(new_backoff)) => {
                                debug!(
                                    task_log,
                                    "error received while waiting for \
                                     stability; restarting wait period"
                                );
                                state = ZkBackoffState::Unstable(new_backoff);
                                continue;
                            }
                            //
                            // Timeout waiting for an error: the stability
                            // threshold has been reached, so reset the backoff
                            //
                            Err(_) => {
                                info!(task_log, "stability threshold reached; resetting backoff");
                                let mut backoff = backoff_clone.lock().await;
                                backoff.reset();
                                state = ZkBackoffState::Stable
                            }
                            //
                            // ZkBackoff object was dropped, so we exit
                            // the thread
                            //
                            Err(RecvTimeoutError::Disconnected) => break,
                        }
                    }
                }
            }
            debug!(task_log, "stability-tracking thread exiting");
        });

        ZkBackoff {
            backoff,
            error_tx,
            log,
        }
    }

    fn next_backoff(&mut self) -> Duration {
        let mut backoff = self.backoff.lock().unwrap();
        //
        // This should never fail because we set max_elapsed_time to `None` in
        // ZkBackoff::new().
        //
        let next_backoff = backoff.next_backoff().expect(
            "next_backoff returned
            None; max_elapsed_time has been reached erroneously",
        );

        //
        // Notify the stability-tracking thread that an error has occurred
        //
        self.error_tx
            .send(ZkBackoffMsg::ErrorOccurred(next_backoff))
            .expect("Error sending over error_tx");

        debug!(self.log, "retrying with backoff {:?}", next_backoff);
        next_backoff
    }
}
